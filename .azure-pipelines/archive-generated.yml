parameters:
- name: TargetModule
  displayName: 'List of target modules, all modules if not provided'
  type: string
  default: 'all'
- name: ForceRegenerate
  displayName: 'Force regenerate autorest generated modules when pipeline triggered manually'
  type: boolean
  default: false

variables:
  WindowsName: windows
  WindowsAgentPoolName: pool-windows-2019
  WindowsAgentPoolVMImage: ''
  LinuxName: linux
  LinuxAgentPoolName: pool-ubuntu-2004
  LinuxAgentPoolVMImage: ''
  MacOSName: macOS
  MacOSAgentPoolName: 'Azure Pipelines'
  MacOSAgentPoolVMImage: macOS-latest
  TestFramework: net6.0
  TestTarget: Test
  Configuration: Debug
  DebugLocalBuildTasks: true
  BuildTimeoutInMinutes: 120
  AnalysisTimeoutInMinutes: 120
  TestTimeoutInMinutes: 180
  BuildAzPredictor: false
  EnableTestCoverage: true
  TestCoverageLocation: $(Build.SourcesDirectory)/artifacts
  PowerShellPlatform: PowerShell Core
  AZURE_CLIENTS_SHOW_SECRETS_WARNING: true

trigger:
  batch: true
  branches:
    include:
      - future

jobs:
- job: Build
  displayName: Build
  condition: succeeded()
  timeoutInMinutes: ${{ variables.BuildTimeoutInMinutes }}
  pool: pool-windows-2019

  steps:
  - checkout: self
  - template: util/get-github-pat-steps.yml
  - task: PowerShell@2
    name: 'Initialize'
    displayName: 'Initialize Build'
    inputs:
      targetType: inline
      pwsh: true
      script: |
        if ("Manual" -eq "$(Build.Reason)") {
          #TODO: change value of $trigger to the account who trigger this run
          $trigger = 'Manual'
        } elseif ("Schedule" -eq "$(Build.Reason)") { 
          #TODO: change value of $trigger to datetime this run was scheduled
          $trigger = 'Schedule'
        } else {
          $trigger = "$(Build.SourceVersion)"
        }
        Write-Host "##vso[task.setvariable variable=Trigger]$trigger"

        $filesChangedOutputPath = Join-Path "$(Build.SourcesDirectory)" 'artifacts' 'FilesChanged.txt'
        Write-Host "##vso[task.setvariable variable=FilesChangedOutputPath]$filesChangedOutputPath"
        New-Item -Type File -Path $filesChangedOutputPath -Force

        $forceRegenerate = $false
        if ('true' -eq '${{ parameters.ForceRegenerate }}') {
          $forceRegenerate = $true
        }

        $filesChangedScriptPath = Join-Path "$(Build.SourcesDirectory)" 'tools' 'BuildScripts' 'FilesChangedScript.psm1'
        Import-Module $filesChangedScriptPath
        $filesChanged = Get-OutdatedModuleFromTargetModule -RepoRoot "$(Build.SourcesDirectory)" -TargetModule "${{ parameters.TargetModule }}" -ForceRegenerate $forceRegenerate
        if (($null -eq $filesChanged) -or (0 -eq $filesChanged.Length)) {
          <# 
            Yabo: have to fail build job to terminate this run because: 
              1. the $  {{ if() }} conditional evaluation is a template expression syntax which was evaluated when compile this YAML, which means cannot use runtime variables in this condition
              2. this job have build template involved and template does not accept condition, and condition does not accept runtime variables either
          #>
          Write-Host "##vso[task.logissue type=warning]no modules found need to be archived, terminate current run."
          exit 1
        }
        #Yabo: cannot use join-path because in ci-config we use slash, backslash cannot match
        $filesChanged | ForEach-Object { 'src/' + $_ } | Out-File $filesChangedOutputPath
  - task: PowerShell@2
    displayName: 'Create branch for generated assets'
    inputs:
      targetType: inline
      pwsh: true
      script: |
        $baseBranchName = "origin/$(Build.SourceBranchName)"
        $tmpBranchName = "archive/$(Build.SourceBranchName)/$(Build.Reason)"
        if ("$(Build.reason)" -in @('IndividualCI', 'BatchedCI')) {
          $tmpBranchName += "/$(Build.SourceVersion)"
        }
        Write-Host "##vso[task.setvariable variable=TmpBranchName]$tmpBranchName"
        Write-Host "##vso[task.setvariable variable=BaseBranchName]$baseBranchName"
        Write-Host "##[section]Switch from $baseBranchName to $tmpBranchName"
        git fetch origin $(Build.SourceBranchName)
        git checkout -b $tmpBranchName $baseBranchName

  - task: UseDotNet@2
    displayName: 'Use .NET Core sdk 6.0.x'
    inputs:
      packageType: sdk
      version: 6.0.x
  - task: NodeTool@0
    displayName: Install Autorest
    inputs:
      versionSpec: '14.17.1'
      command: custom
      verbose: false
      customCommand: install autorest@latest
  - task: PowerShell@2
    displayName: Setup environment for Autorest
    inputs:
      targetType: inline
      script: "$env:NODE_OPTIONS=\"--max-old-space-size=65536\""
      pwsh: true
  - task: PowerShell@2
    displayName: 'Build'
    inputs:
      targetType: inline
      pwsh: true
      script: util/PipelineSteps/build-steps.ps1 -RepoRoot ${{ Build.SourcesDirectory }} -Configuration ${{ variables.Configuration }} -PowerShellPlatform ${{ variables.PowerShellPlatform }} -FilesChangedOutputPath $(FilesChangedOutputPath) -ForceRegenerate ${{ parameters.ForceRegenerate }} -BuildReason ${{ Build.Reason }} -Trigger $(Trigger)
  - task: PowerShell@2
    displayName: 'push archive branch after build'
    inputs:
      targetType: inline
      pwsh: true
      script: |
        if ("$(Build.reason)" -in @('IndividualCI', 'BatchedCI')) {
          $prTitle = "[skip ci] Archive $(Build.SourceVersion)"
        } else {
          #TODO: replace $(Build.reason) with account when manual and datetime when schedule
          $prTitle = "[skip ci] Archive $(Build.reason)"
        }
        $tmpBranchName = "$(TmpBranchName)"
        $baseBranchName = "$(BaseBranchName)"
        $generatedPath = Join-Path "$(Build.SourcesDirectory)" 'generated'
        $diff = ( git status --short --untracked-files $generatedPath)
        if ((-not $diff) -or ($null -eq $diff) -or (0 -eq $diff.Count)) {
          return
        }
        #TODO: add better PR description
        $prDescription = ""
        $prScriptPath = Join-Path "$(Build.SourcesDirectory)" 'tools' 'Github' 'CreatePR.ps1'

        git config user.email "65331932+azure-powershell-bot@users.noreply.github.com";
        git config user.name "azure-powershell-bot";
        git remote set-url origin https://azure-powershell-bot:$(GithubToken)@github.com/Azure/azure-powershell.git;
        git add $generatedPath
        git commit -m $prTitle
        git push origin $tmpBranchName --force
        
        . $prScriptPath -Title $prTitle -HeadBranch $tmpBranchName -BaseBranch "$(Build.SourceBranchName)" -BotAccessToken $(GithubToken) -Description $prDescription

        <#
          this commidId will be useful when we push directly to target branch in the future
          $commitId = (git rev-parse HEAD)
        #>

- job: Analyze
  displayName: Analyze
  dependsOn: Build
  condition: succeeded()
  timeoutInMinutes: ${{ variables.AnalysisTimeoutInMinutes }}
  pool: pool-windows-2019
  steps:
  - template: util/download-build-steps.yml
    parameters:
      artifactName: build-${{ variables.TestFramework }}
  - task: NodeTool@0
    displayName: Install autorest
    inputs:
      versionSpec: '14.17.1'
      command: custom
      verbose: false
      customCommand: install autorest@latest
  - task: PowerShell@2
    displayName: Setup environment for autorest
    inputs:
      targetType: inline
      script: "$env:NODE_OPTIONS=\"--max-old-space-size=65536\""
      pwsh: true
  - task: UseDotNet@2
    displayName: 'Use .NET Core sdk 6.0.x'
    inputs:
      packageType: sdk
      version: 6.0.x
  - task: PowerShell@2
    displayName: 'Analyze'
    inputs:
      targetType: inline
      pwsh: true
      script: util/PipelineSteps/analyze-steps.ps1 -RepoRoot ${{ Build.SourcesDirectory }} -Configuration ${{ variables.Configuration }} -PowerShellPlatform ${{ variables.PowerShellPlatform }}
  - template: util/publish-artifacts-steps.yml
    parameters:
      artifactName: analyze-${{ variables.testFramework }}-$(System.JobAttempt)

- job: Test
  displayName: Test
  dependsOn: Build
  condition: succeeded()
  timeoutInMinutes: ${{ variables.TestTimeoutInMinutes }}
  strategy:
    matrix:
      windows:
        OSName: ${{ variables.WindowsName }}
        agentPoolName: ${{ variables.WindowsAgentPoolName }}
        agentPoolVMImage: ${{ variables.WindowsAgentPoolVMImage }}
      linux:
        OSName: ${{ variables.LinuxName }}
        agentPoolName: ${{ variables.LinuxAgentPoolName }}
        agentPoolVMImage: ${{ variables.LinuxAgentPoolVMImage }}
      macOS:
        OSName: ${{ variables.MacOSName }}
        agentPoolName: ${{ variables.MacOSAgentPoolName }}
        agentPoolVMImage: ${{ variables.MacOSAgentPoolVMImage }}
  pool:
    name: $(agentPoolName)
    vmImage: $(agentPoolVMImage)
  steps:
  - template: util/download-build-steps.yml
    parameters:
      artifactName: build-${{ variables.TestFramework }}
  - task: UseDotNet@2
    displayName: 'Use .NET SDK 6 for tests'
    inputs:
      packageType: sdk
      version: 6.0.x
  - task: PublishTestResults@2
    inputs:
      testRunner: VSTest
      testResultsFiles: '**/*.trx'
  - template: publish-artifacts-steps.yml
    parameters:
      artifactName: test-${{ variables.testFramework }}-${{ variables.OSName }}-$(System.JobAttempt)